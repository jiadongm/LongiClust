library(ggplot2)
library(dplyr)
library(tidyr)
set.seed(42)  # For reproducibility
# Parameters
n_total <- 100  # Total number of functions
n_per_group <- 50  # Functions per group
n_timepoints <- 20  # Number of time points
time_grid <- seq(0, 10, length.out = n_timepoints)  # Time grid from 0 to 10
# Function to generate basis functions for smooth curves
generate_basis <- function(t, n_basis = 5) {
# Using Fourier basis for smooth periodic-like patterns
basis <- matrix(0, length(t), n_basis)
for (i in 1:n_basis) {
if (i %% 2 == 1) {
basis[, i] <- sin(2 * pi * (i %/% 2 + 1) * t / max(t))
} else {
basis[, i] <- cos(2 * pi * (i %/% 2) * t / max(t))
}
}
return(basis)
}
# Generate basis
basis <- generate_basis(time_grid, n_basis = 5)
# Population 1: Early response pattern (e.g., treatment responders)
# Characterized by early peak and gradual decline
pop1_functions <- matrix(NA, n_per_group, n_timepoints)
pop1_coefficients <- matrix(NA, n_per_group, 5)
for (i in 1:n_per_group) {
# Random coefficients with population-specific mean structure
coef <- c(
rnorm(1, mean = 3, sd = 0.5),   # Strong early component
rnorm(1, mean = -2, sd = 0.3),  # Negative second component
rnorm(1, mean = 0.5, sd = 0.2),
rnorm(1, mean = -0.3, sd = 0.2),
rnorm(1, mean = 0.1, sd = 0.1)
)
pop1_coefficients[i, ] <- coef
# Generate smooth function
smooth_func <- basis %*% coef
# Add measurement noise (heteroscedastic - higher at peaks)
noise_sd <- 0.3 + 0.1 * abs(smooth_func)
noise <- rnorm(n_timepoints, mean = 0, sd = noise_sd)
pop1_functions[i, ] <- smooth_func + noise
}
# Population 2: Late response pattern (e.g., non-responders or delayed responders)
# Characterized by delayed peak and sustained elevation
pop2_functions <- matrix(NA, n_per_group, n_timepoints)
pop2_coefficients <- matrix(NA, n_per_group, 5)
for (i in 1:n_per_group) {
# Random coefficients with different population-specific mean structure
coef <- c(
rnorm(1, mean = 0.5, sd = 0.3),   # Weaker early component
rnorm(1, mean = 1.5, sd = 0.4),   # Positive second component
rnorm(1, mean = 2, sd = 0.5),     # Strong third component
rnorm(1, mean = 0.8, sd = 0.3),
rnorm(1, mean = -0.5, sd = 0.2)
)
pop2_coefficients[i, ] <- coef
# Generate smooth function
smooth_func <- basis %*% coef
# Add measurement noise
noise_sd <- 0.3 + 0.1 * abs(smooth_func)
noise <- rnorm(n_timepoints, mean = 0, sd = noise_sd)
pop2_functions[i, ] <- smooth_func + noise
}
# Combine all functions
all_functions <- rbind(pop1_functions, pop2_functions)
true_labels <- c(rep(1, n_per_group), rep(2, n_per_group))
# Create a data frame for visualization
df_long <- data.frame(
ID = rep(1:n_total, each = n_timepoints),
Time = rep(time_grid, n_total),
Value = as.vector(t(all_functions)),
Population = factor(rep(true_labels, each = n_timepoints))
)
# Visualization
library(ggplot2)
# Plot 1: All trajectories with population colors
p1 <- ggplot(df_long, aes(x = Time, y = Value, group = ID, color = Population)) +
geom_line(alpha = 0.3) +
scale_color_manual(values = c("1" = "#E41A1C", "2" = "#377EB8"),
labels = c("Population 1 (Early)", "Population 2 (Late)")) +
theme_minimal() +
labs(title = "Simulated Longitudinal Functions",
subtitle = "100 functions from two populations with distinct temporal patterns",
x = "Time",
y = "Expression Level") +
theme(legend.position = "bottom")
# Plot 2: Mean trajectories with confidence bands
df_summary <- df_long %>%
group_by(Time, Population) %>%
summarise(
Mean = mean(Value),
SE = sd(Value) / sqrt(n()),
Lower = Mean - 1.96 * SE,
Upper = Mean + 1.96 * SE,
.groups = "drop"
)
p2 <- ggplot(df_summary, aes(x = Time, color = Population, fill = Population)) +
geom_ribbon(aes(ymin = Lower, ymax = Upper), alpha = 0.3, linetype = 0) +
geom_line(aes(y = Mean), size = 1.2) +
scale_color_manual(values = c("1" = "#E41A1C", "2" = "#377EB8"),
labels = c("Population 1 (Early)", "Population 2 (Late)")) +
scale_fill_manual(values = c("1" = "#E41A1C", "2" = "#377EB8"),
labels = c("Population 1 (Early)", "Population 2 (Late)")) +
theme_minimal() +
labs(title = "Mean Trajectories with 95% Confidence Bands",
subtitle = "Showing distinct temporal patterns between populations",
x = "Time",
y = "Mean Expression Level") +
theme(legend.position = "bottom")
# Display plots
print(p1)
print(p2)
# Export data for further analysis
longitudinal_data <- list(
functions = all_functions,           # n x p matrix of functions
time_grid = time_grid,               # Time points
true_labels = true_labels,           # True cluster labels
population1_coef = pop1_coefficients, # Basis coefficients for pop1
population2_coef = pop2_coefficients, # Basis coefficients for pop2
basis = basis,                       # Basis functions used
data_frame = df_long                 # Long format data frame
)
setwd("~/Dropbox/Research_projects/LongiClust")
# Save for use in package development
saveRDS(longitudinal_data, "data/simulated_longitudinal_data.rds")
simDat <- readRDS("data/simulated_longitudinal_data.rds")
source("~/Documents/GitHub/LongiClust/R/generateRP.R", echo = TRUE)
simDat$time_grid
source("~/Documents/GitHub/LongiClust/R/generateRP.R", echo = TRUE)
RP <- generateRP(B = 100, d0 = 1, r = 5, grid = simDat$time_grid)
simDat$time_grid
B = 100
d0 = 1
r = 5
B = 100
d0 = 1
r = 5
grid = simDat$time_grid
# Validate inputs
if (B <= 0 || d0 <= 0 || r <= 0) {
stop("B, d0, and r must be positive integers")
}
# Handle basis specification
if (is.character(basis)) {
basis <- tolower(basis)
if (basis == "fourier") {
basis_functions <- create_fourier_basis(r, grid)
basis_type <- "fourier"
} else if (basis == "bspline") {
basis_functions <- create_bspline_basis(r, grid, degree = bspline_degree)
basis_type <- "bspline"
} else {
stop("basis must be 'fourier', 'bspline', or a matrix")
}
} else if (is.matrix(basis)) {
# User provided custom basis
basis_functions <- basis
basis_type <- "custom"
# Validate custom basis dimensions
if (nrow(basis_functions) != r) {
stop(paste("Custom basis matrix must have r =", r, "rows"))
}
if (ncol(basis_functions) != length(grid)) {
stop(paste("Custom basis matrix must have", length(grid),
"columns to match grid length"))
}
} else {
stop("basis must be a character string ('fourier' or 'bspline') or a matrix")
}
is.character(basis)
basis = "fourier"
if (basis == "fourier") {
basis_functions <- create_fourier_basis(r, grid)
basis_type <- "fourier"
} else if (basis == "bspline") {
basis_functions <- create_bspline_basis(r, grid, degree = bspline_degree)
basis_type <- "bspline"
} else {
stop("basis must be 'fourier', 'bspline', or a matrix")
}
# VECTORIZED APPROACH: Generate all B*d0 random coefficient vectors at once
# Draw all random coefficients in one call: B*d0 rows, r columns
all_coefficients <- matrix(rnorm(B * d0 * r), nrow = B * d0, ncol = r)
# Normalize each row to unit length using vectorized operations
row_norms <- sqrt(rowSums(all_coefficients^2))
all_coefficients <- all_coefficients / row_norms
# Reshape into 3D array: B x d0 x r for easier indexing
coef_array <- array(all_coefficients, dim = c(d0, B, r))
coef_array <- aperm(coef_array, c(2, 1, 3))  # Permute to B x d0 x r
# Pre-allocate the entire list structure
Q_B <- vector("list", B)
# Build projection objects efficiently
for (b in 1:B) {
# Extract coefficient matrix for this projection (d0 x r)
coef_matrix <- coef_array[b, , ]
# Create list of d0 projection functions
Psi_b <- lapply(1:d0, function(j) {
list(
coefficients = coef_matrix[j, ],
basis = basis_functions,
grid = grid
)
})
# Store this projection
Q_B[[b]] <- list(
Psi = Psi_b,
coefficients = coef_matrix,
projection_id = b
)
}
b
# Extract coefficient matrix for this projection (d0 x r)
coef_matrix <- coef_array[b, , ]
coef_matrix
# Create list of d0 projection functions
Psi_b <- lapply(1:d0, function(j) {
list(
coefficients = coef_matrix[j, ],
basis = basis_functions,
grid = grid
)
})
# Build projection objects efficiently
for (b in 1:B) {
# Extract coefficient matrix for this projection (d0 x r)
coef_matrix <- coef_array[b, , ,drop=FALSE]
# Create list of d0 projection functions
Psi_b <- lapply(1:d0, function(j) {
list(
coefficients = coef_matrix[j, ],
basis = basis_functions,
grid = grid
)
})
# Store this projection
Q_B[[b]] <- list(
Psi = Psi_b,
coefficients = coef_matrix,
projection_id = b
)
}
# Extract coefficient matrix for this projection (d0 x r)
coef_matrix <- coef_array[b, , ,drop=FALSE]
coef_matrix
# Extract coefficient matrix for this projection (d0 x r)
coef_matrix <- coef_array[b, , drop=FALSE]
# Extract coefficient matrix for this projection (d0 x r)
coef_matrix <- coef_array[b, ,]
# Convert vector back to matrix when d0=1
coef_matrix <- as.matrix(coef_matrix)
# Create list of d0 projection functions
Psi_b <- lapply(1:d0, function(j) {
list(
coefficients = coef_matrix[j, ],
basis = basis_functions,
grid = grid
)
})
# Store this projection
Q_B[[b]] <- list(
Psi = Psi_b,
coefficients = coef_matrix,
projection_id = b
)
# Build projection objects efficiently
for (b in 1:B) {
# Extract coefficient matrix for this projection (d0 x r)
coef_matrix <- coef_array[b, ,]
# Convert vector back to matrix when d0=1
coef_matrix <- as.matrix(coef_matrix)
# Create list of d0 projection functions
Psi_b <- lapply(1:d0, function(j) {
list(
coefficients = coef_matrix[j, ],
basis = basis_functions,
grid = grid
)
})
# Store this projection
Q_B[[b]] <- list(
Psi = Psi_b,
coefficients = coef_matrix,
projection_id = b
)
}
source("~/Documents/GitHub/LongiClust/R/generateRP.R", echo = TRUE)
B = 100
d0 = 1
r = 5
basis = "fourier"
grid = simDat$time_grid
RP <- generateRP(B, d0, r, grid)
source("~/Documents/GitHub/LongiClust/R/generateRP.R", echo = TRUE)
RP <- generateRP(B, d0, r, grid)
RP <- generateRP(B, d0, r, basis, grid, bspline_degree = 3)
RP
RP[[1]]
source("~/Documents/GitHub/LongiClust/R/generateRP.R", echo = TRUE)
B = 100
d0 = 1
r = 5
basis = "fourier"
grid = simDat$time_grid
RP <- generateRP(B, d0, r, basis, grid, bspline_degree = 3)
source("~/Documents/GitHub/LongiClust/R/generateRP.R", echo = TRUE)
B = 100
d0 = 1
r = 5
basis = "fourier"
grid = simDat$time_grid
RP <- generateRP(B, d0, r, basis, grid, bspline_degree = 3)
source("~/Documents/GitHub/LongiClust/R/generateRP.R", echo = TRUE)
source("~/Documents/GitHub/LongiClust/R/generateRP.R", echo = TRUE)
RP <- generateRP(B, d0, r, basis, grid, bspline_degree = 3)
plot_basis_functions(RP)
source("~/Documents/GitHub/LongiClust/R/generateRP.R", echo = TRUE)
RP <- generateRP(B, d0, r, basis, grid, bspline_degree = 3)
source("~/Documents/GitHub/LongiClust/R/generateRP.R", echo = TRUE)
RP <- generateRP(B, d0, r, basis, grid, bspline_degree = 3)
plot_basis_functions(RP)
plot.random_projections(RP)
plot.random_projections(RP, type = "both")
source("~/Documents/GitHub/LongiClust/R/generateRP.R", echo = TRUE)
simDat <- readRDS("data/simulated_longitudinal_data.rds")
simDat$time_grid
B = 100
d0 = 1
r = 5
basis = "fourier"
grid = simDat$time_grid
RP <- generateRP(B, d0, r, basis, grid, bspline_degree = 3)
plot.random_projections(RP, type = "both")
source("~/Documents/GitHub/LongiClust/R/generateRP.R", echo = TRUE)
RP <- generateRP(B, d0, r, basis, grid, bspline_degree = 3)
plot.random_projections(RP, type = "both")
plot.random_projections(RP, type = "both")
B = 100
d0 = 1
r = 5
grid = simDat$time_grid
RP <- generateRP(B, d0, r, basis, grid, bspline_degree = 3)
plot.random_projections(RP, type = "both")
source("~/Documents/GitHub/LongiClust/R/generateRP.R", echo = TRUE)
simDat <- readRDS("data/simulated_longitudinal_data.rds")
simDat$time_grid
B = 100
d0 = 1
r = 5
grid = simDat$time_grid
RP <- generateRP(B, d0, r, basis, grid, bspline_degree = 3)
RP <- generateRP(B, d0, r, basis = "bspline", grid, bspline_degree = 3)
plot.random_projections(RP, type = "both")
devtools::check()
setwd("~/Documents/GitHub/LongiClust")
devtools::check()
source("~/Documents/GitHub/LongiClust/R/generateRP.R", echo = TRUE)
simDat <- readRDS("data/simulated_longitudinal_data.rds")
simDat <- readRDS("~/Dropbox/Research_projects/LongiClust/data/simulated_longitudinal_data.rds")
simDat$time_grid
source("~/Documents/GitHub/LongiClust/R/generateRP.R", echo = TRUE)
B = 100
d0 = 1
r = 5
grid = simDat$time_grid
RP <- generateRP(B, d0, r, basis = "bspline", grid, bspline_degree = 3)
plot.random_projections(RP, type = "both")
plot.random_projections(RP, type = "both")
RP <- generateRP(B, d0, r, basis = "bspline", grid, bspline_degree = 3)
plot.random_projections(RP, type = "both")
devtools::check()
library(devtools)
use_mit_license()
document()
library(devtools)
document()
check()
check()
check()
check()
?par
?rainbow
?lines
check()
check()
check()
check()
check()
check()
check()
check()
check()
